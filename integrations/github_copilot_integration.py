#!/usr/bin/env python3
"""
SuperManUS Task Enforcement - GitHub Copilot Integration
Wrapper and hooks for GitHub Copilot with task enforcement
"""

import os
import sys
import json
import subprocess
from pathlib import Path
from typing import Dict, Any, List, Optional

# Add SuperManUS to path
SUPERMANUS_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(SUPERMANUS_ROOT / 'src'))

try:
    from utils.task_enforcer import get_enforcer
    from utils.llm_guard import LLMActionGuard, TaskViolationException
except ImportError as e:
    print(f"‚ö†Ô∏è  SuperManUS enforcement not available: {e}")

class EnforcedCopilot:
    """
    Integration layer for GitHub Copilot with SuperManUS task enforcement
    Adds task context and validation to Copilot suggestions
    """
    
    def __init__(self, project_root: str = None):
        self.project_root = Path(project_root or os.getcwd())
        self.enforcer = get_enforcer()
    
    def generate_task_context_comment(self) -> str:
        """
        Generate context comment to prepend to files for Copilot
        This gives Copilot the task context for better suggestions
        """
        
        if not self.enforcer.current_task:
            return "/* ‚ö†Ô∏è  No active SuperManUS task - select one first */"
        
        task_id = self.enforcer.current_task["id"]
        proof_req = self.enforcer.require_completion_proof()
        
        context = f"""/*
 * SuperManUS Active Task: {task_id}
 * 
 * COPILOT CONSTRAINTS:
 * - All suggestions must advance this specific task
 * - No unrelated features or refactoring
 * - Follow existing project patterns
 * 
 * COMPLETION REQUIREMENTS:
"""
        
        for req_type, description in proof_req.get('requirements', {}).items():
            context += f" * - {req_type}: {description}\n"
        
        context += f"""*
 * Focus on: {task_id}
 */

"""
        return context
    
    def inject_task_context_into_file(self, file_path: str) -> bool:
        """
        Inject task context at the top of file for Copilot to see
        """
        
        file_path = Path(file_path)
        if not file_path.exists():
            return False
        
        # Read existing content
        with open(file_path, 'r') as f:
            content = f.read()
        
        # Check if context already exists
        if "SuperManUS Active Task:" in content:
            return True  # Already has context
        
        # Generate and prepend context
        context = self.generate_task_context_comment()
        
        # Write back with context
        with open(file_path, 'w') as f:
            f.write(context + content)
        
        return True
    
    def create_copilot_prompt_file(self) -> Path:
        """
        Create a .copilot-instructions.md file with task-specific guidance
        """
        
        if not self.enforcer.current_task:
            return None
        
        task_id = self.enforcer.current_task["id"]
        proof_req = self.enforcer.require_completion_proof()
        
        instructions = f"""# GitHub Copilot Instructions - SuperManUS Integration

## üéØ ACTIVE TASK
{task_id}

## ‚ö° COPILOT BEHAVIOR RULES

### ‚úÖ DO:
- Suggest code that directly advances the current task
- Follow existing project patterns and conventions
- Consider the completion requirements listed below
- Provide incremental, testable implementations
- Add comments explaining task relevance

### ‚ùå DON'T:
- Suggest unrelated features or improvements
- Refactor code unless directly required by task
- Add dependencies not needed for current task
- Suggest breaking changes without task justification

## üìã COMPLETION REQUIREMENTS

Task completion requires proof of:
"""
        
        for req_type, description in proof_req.get('requirements', {}).items():
            instructions += f"- **{req_type}**: {description}\n"
        
        instructions += f"""
## üîß VALIDATION COMMANDS

These commands will be used to validate task completion:
"""
        
        for cmd in proof_req.get('validation_commands', []):
            instructions += f"```bash\n{cmd}\n```\n"
        
        instructions += f"""
## üí° SUGGESTION STRATEGY

When suggesting code:
1. Always consider how it advances: {task_id}
2. Ensure suggestions are testable with the validation commands above
3. Keep implementations simple and focused
4. Add task-relevant comments to explain purpose

## üö´ SCOPE BOUNDARIES

Current task scope: {task_id}
Do not suggest anything outside this scope.

---
*Auto-generated by SuperManUS Task Enforcer*
*Updated: {self.enforcer.current_task.get('start_time', 'Unknown')}*
"""
        
        instructions_file = self.project_root / ".copilot-instructions.md"
        with open(instructions_file, 'w') as f:
            f.write(instructions)
        
        return instructions_file
    
    def validate_copilot_suggestion(self, suggestion: str, file_context: str = "") -> Dict[str, Any]:
        """
        Validate Copilot suggestion against current task
        """
        
        if not self.enforcer.current_task:
            return {
                "valid": False,
                "message": "‚ùå No active task - select one first"
            }
        
        # Simple heuristic validation - can be enhanced
        task_keywords = self._extract_task_keywords(self.enforcer.current_task["id"])
        suggestion_lower = suggestion.lower()
        file_context_lower = file_context.lower()
        
        # Check if suggestion seems related to task
        relevance_score = 0
        for keyword in task_keywords:
            if keyword in suggestion_lower or keyword in file_context_lower:
                relevance_score += 1
        
        is_relevant = relevance_score > 0 or len(task_keywords) == 0
        
        if not is_relevant:
            return {
                "valid": False,
                "message": f"‚ùå Suggestion doesn't seem related to task: {self.enforcer.current_task['id']}",
                "suggestion": "Add task-relevant comments or modify to advance current task"
            }
        
        # Enhanced suggestion with task context
        enhanced_suggestion = f"// Task: {self.enforcer.current_task['id']}\n{suggestion}"
        
        return {
            "valid": True,
            "message": "‚úÖ Suggestion appears task-relevant",
            "enhanced_suggestion": enhanced_suggestion,
            "relevance_score": relevance_score
        }
    
    def _extract_task_keywords(self, task_id: str) -> List[str]:
        """Extract keywords from task ID for relevance checking"""
        # Simple keyword extraction
        words = task_id.lower().replace(":", " ").replace("-", " ").split()
        return [word for word in words if len(word) > 3]
    
    def setup_copilot_workspace(self) -> Dict[str, Any]:
        """
        Set up workspace for optimal Copilot integration
        """
        
        results = {
            "instructions_file": None,
            "context_injected": [],
            "settings_created": False
        }
        
        # Create Copilot instructions
        instructions_file = self.create_copilot_prompt_file()
        if instructions_file:
            results["instructions_file"] = str(instructions_file)
        
        # Inject context into Python files
        for py_file in self.project_root.glob("**/*.py"):
            if py_file.is_file() and not py_file.name.startswith("__"):
                if self.inject_task_context_into_file(py_file):
                    results["context_injected"].append(str(py_file))
        
        # Create VS Code settings for Copilot
        vscode_dir = self.project_root / ".vscode"
        vscode_dir.mkdir(exist_ok=True)
        
        copilot_settings = {
            "github.copilot.enable": {
                "*": True,
                "yaml": False,  # Reduce noise in config files
                "plaintext": False
            },
            "github.copilot.advanced": {
                "secret_key": "supermanus_task_enforcement",
                "length": 500,  # Shorter suggestions to stay focused
                "temperature": 0.1,  # More deterministic suggestions
                "top_p": 0.1,
                "presence_penalty": 0.1,
                "frequency_penalty": 0.1
            },
            "editor.inlineSuggest.enabled": True,
            "editor.quickSuggestions": {
                "other": True,
                "comments": True,
                "strings": True
            }
        }
        
        settings_file = vscode_dir / "copilot-settings.json"
        with open(settings_file, 'w') as f:
            json.dump(copilot_settings, f, indent=2)
        
        results["settings_created"] = True
        
        return results

# Copilot integration functions

def setup_copilot_enforcement(project_root: str = None) -> bool:
    """
    Set up GitHub Copilot with SuperManUS task enforcement
    """
    
    copilot = EnforcedCopilot(project_root)
    
    print("ü§ñ Setting up GitHub Copilot with SuperManUS enforcement...")
    
    results = copilot.setup_copilot_workspace()
    
    if results["instructions_file"]:
        print(f"‚úÖ Created Copilot instructions: {Path(results['instructions_file']).name}")
    
    if results["context_injected"]:
        print(f"‚úÖ Injected task context into {len(results['context_injected'])} Python files")
    
    if results["settings_created"]:
        print("‚úÖ Created Copilot-optimized VS Code settings")
    
    print("\nüéØ GitHub Copilot integration complete!")
    print("Copilot will now suggest code aligned with your active SuperManUS task.")
    
    return True

def get_copilot_context() -> str:
    """Get current task context for Copilot"""
    copilot = EnforcedCopilot()
    return copilot.generate_task_context_comment()

def validate_copilot_code(suggestion: str, context: str = "") -> bool:
    """Validate Copilot suggestion against current task"""
    copilot = EnforcedCopilot()
    result = copilot.validate_copilot_suggestion(suggestion, context)
    return result.get("valid", False)

def inject_task_context(file_path: str) -> bool:
    """Inject task context into specific file"""
    copilot = EnforcedCopilot()
    return copilot.inject_task_context_into_file(file_path)

# Copilot CLI integration
def copilot_chat_with_task_context(prompt: str) -> str:
    """
    Enhanced Copilot chat that includes task context
    """
    
    copilot = EnforcedCopilot()
    
    if not copilot.enforcer.current_task:
        return "‚ùå No active task. Select a SuperManUS task first."
    
    # Enhance prompt with task context
    enhanced_prompt = f"""
Task Context: {copilot.enforcer.current_task['id']}

Constraints:
- All suggestions must advance the current task
- Follow existing project patterns
- Consider completion requirements

User Request: {prompt}

Please provide suggestions that specifically advance the current task.
"""
    
    # This would integrate with actual Copilot CLI if available
    # For now, return the enhanced prompt
    return enhanced_prompt

# Testing function
def test_copilot_integration():
    """Test Copilot integration functionality"""
    
    print("üß™ Testing GitHub Copilot Integration")
    print("-" * 45)
    
    copilot = EnforcedCopilot()
    
    # Test context generation
    print("1. Testing context generation...")
    context = copilot.generate_task_context_comment()
    print(f"Context length: {len(context)} characters")
    
    # Test suggestion validation
    print("\n2. Testing suggestion validation...")
    result = copilot.validate_copilot_suggestion(
        "def process_data(): return True", 
        "data processing module"
    )
    print(f"Validation result: {result.get('message', 'No message')}")
    
    # Test workspace setup
    print("\n3. Testing workspace setup...")
    results = copilot.setup_copilot_workspace()
    print(f"Instructions file: {bool(results.get('instructions_file'))}")
    print(f"Settings created: {results.get('settings_created', False)}")
    
    print("\n‚úÖ Copilot integration test complete!")

if __name__ == "__main__":
    test_copilot_integration()